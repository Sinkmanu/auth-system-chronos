###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.40338/W32 for 8051         26/Nov/2012  10:49:37 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  near                                               #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Documents and Settings\usuario\Mis              #
#                          documentos\Server_IAR\simpliciti\Components\nwk_ap #
#                          plications\nwk_ioctl.c                             #
#    Command line       =  -f "C:\Documents and Settings\usuario\Mis          #
#                          documentos\Server_IAR\simpliciti\Configuration\Acc #
#                          ess Point\smpl_config.dat" (-DNUM_CONNECTIONS=1    #
#                          -DSIZE_INFRAME_Q=6 -DSIZE_OUTFRAME_Q=2             #
#                          "-DTHIS_DEVICE_ADDRESS={0x78, 0x56, 0x34, 0x10}"   #
#                          -DACCESS_POINT -DAP_IS_DATA_HUB                    #
#                          -DNUM_STORE_AND_FWD_CLIENTS=3                      #
#                          -DSTARTUP_JOINCONTEXT_ON) -f "C:\Documents and     #
#                          Settings\usuario\Mis documentos\Server_IAR\simplic #
#                          iti\Configuration\smpl_nwk_config.dat"             #
#                          (-DMAX_HOPS=3 -DMAX_HOPS_FROM_AP=1                 #
#                          -DMAX_NWK_PAYLOAD=9 -DMAX_APP_PAYLOAD=19           #
#                          -DDEFAULT_LINK_TOKEN=0x01020304                    #
#                          -DDEFAULT_JOIN_TOKEN=0x05060708 -DAPP_AUTO_ACK     #
#                          -DEXTENDED_API -DxSMPL_SECURE -DxNVOBJECT_SUPPORT  #
#                          -DxSW_TIMER) "C:\Documents and                     #
#                          Settings\usuario\Mis documentos\Server_IAR\simplic #
#                          iti\Components\nwk_applications\nwk_ioctl.c" -D    #
#                          CC1111EM -D ISM_EU -D MCU_H=<ioCC1111.h> -D        #
#                          chip=1111 -D RF_FREQUENCY=868000 -D MRFI_CC1111    #
#                          -D NDEBUG -lC "C:\Documents and                    #
#                          Settings\usuario\Mis documentos\Server_IAR\868MHz  #
#                          - Unrestricted IAR Workbench (Europe)\List\" -o    #
#                          "C:\Documents and Settings\usuario\Mis             #
#                          documentos\Server_IAR\868MHz - Unrestricted IAR    #
#                          Workbench (Europe)\Obj\" -e --no_unroll            #
#                          --no_inline --no_tbaa --debug --core=plain         #
#                          --dptr=16,1 --data_model=large --code_model=near   #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Documents and Settings\usuario\Mis             #
#                          documentos\Server_IAR\bm-br1\" -I "C:\Documents    #
#                          and Settings\usuario\Mis                           #
#                          documentos\Server_IAR\HAL\include\" -I             #
#                          "C:\Documents and Settings\usuario\Mis             #
#                          documentos\Server_IAR\HAL\source\" -I              #
#                          "C:\Documents and Settings\usuario\Mis             #
#                          documentos\Server_IAR\wbsl\" -I "C:\Documents and  #
#                          Settings\usuario\Mis documentos\Server_IAR\usb\"   #
#                          -I "C:\Documents and Settings\usuario\Mis          #
#                          documentos\Server_IAR\usb\class_cdc\" -I           #
#                          "C:\Documents and Settings\usuario\Mis             #
#                          documentos\Server_IAR\usb\library\" -I             #
#                          "C:\Documents and Settings\usuario\Mis             #
#                          documentos\Server_IAR\usb\library\ccxx11\" -I      #
#                          "C:\Documents and Settings\usuario\Mis             #
#                          documentos\Server_IAR\sync\" -I "C:\Documents and  #
#                          Settings\usuario\Mis documentos\Server_IAR\simplic #
#                          iti\" -I "C:\Documents and Settings\usuario\Mis    #
#                          documentos\Server_IAR\simpliciti\Components\bsp\"  #
#                          -I "C:\Documents and Settings\usuario\Mis          #
#                          documentos\Server_IAR\simpliciti\Components\bsp\dr #
#                          ivers\" -I "C:\Documents and Settings\usuario\Mis  #
#                          documentos\Server_IAR\simpliciti\Components\bsp\bo #
#                          ards\RFUSB\" -I "C:\Documents and                  #
#                          Settings\usuario\Mis documentos\Server_IAR\simplic #
#                          iti\Components\mrfi\" -I "C:\Documents and         #
#                          Settings\usuario\Mis documentos\Server_IAR\simplic #
#                          iti\Components\nwk\" -I "C:\Documents and          #
#                          Settings\usuario\Mis documentos\Server_IAR\simplic #
#                          iti\Components\nwk_applications\" -Om              #
#    List file          =  C:\Documents and Settings\usuario\Mis              #
#                          documentos\Server_IAR\868MHz - Unrestricted IAR    #
#                          Workbench (Europe)\List\nwk_ioctl.lst              #
#    Object file        =  C:\Documents and Settings\usuario\Mis              #
#                          documentos\Server_IAR\868MHz - Unrestricted IAR    #
#                          Workbench (Europe)\Obj\nwk_ioctl.r51               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\usuario\Mis documentos\Server_IAR\simpliciti\Components\nwk_applications\nwk_ioctl.c
      1          
      2          /**************************************************************************************************
      3            Filename:       nwk_ioctl.c
      4            Revised:        $Date: 2009-01-13 11:31:14 -0800 (Tue, 13 Jan 2009) $
      5            Revision:       $Revision: 18744 $
      6            Author:         $Author: lfriedman $
      7          
      8            Description:    This file supports the SimpliciTI IOCTL implmentation. This interface
      9                            gives applications access to the "driver" network level functions
     10                            when necessary.
     11          
     12            Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
     13          
     14            IMPORTANT: Your use of this Software is limited to those specific rights granted under
     15            the terms of a software license agreement between the user who downloaded the software,
     16            his/her employer (which must be your employer) and Texas Instruments Incorporated (the
     17            "License"). You may not use this Software unless you agree to abide by the terms of the
     18            License. The License limits your use, and you acknowledge, that the Software may not be
     19            modified, copied or distributed unless embedded on a Texas Instruments microcontroller
     20            or used solely and exclusively in conjunction with a Texas Instruments radio frequency
     21            transceiver, which is integrated into your product. Other than for the foregoing purpose,
     22            you may not use, reproduce, copy, prepare derivative works of, modify, distribute,
     23            perform, display or sell this Software and/or its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS”
     26            WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY
     27            WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
     28            IN NO EVENT SHALL TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE
     30            THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY
     31            INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST
     32            DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY
     33            THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com.
     37          **************************************************************************************************/
     38          
     39          
     40          /******************************************************************************
     41           * INCLUDES
     42           */
     43          #include <string.h>
     44          #include "bsp.h"
     45          #include "mrfi.h"
     46          #include "nwk_types.h"
     47          #include "nwk_frame.h"
     48          #include "nwk.h"
     49          #include "nwk_ioctl.h"
     50          #include "nwk_globals.h"
     51          #include "nwk_security.h"
     52          #ifdef ACCESS_POINT
     53          #include "nwk_join.h"
     54          #endif
     55          
     56          /******************************************************************************
     57           * MACROS
     58           */
     59          
     60          /******************************************************************************
     61           * CONSTANTS AND DEFINES
     62           */
     63          
     64          /******************************************************************************
     65           * TYPEDEFS
     66           */
     67          
     68          /******************************************************************************
     69           * LOCAL VARIABLES
     70           */
     71          
     72          /******************************************************************************
     73           * LOCAL FUNCTIONS
     74           */
     75          
     76          /******************************************************************************
     77           * GLOBAL VARIABLES
     78           */
     79          
     80          /******************************************************************************
     81           * GLOBAL FUNCTIONS
     82           */
     83          
     84          
     85          /******************************************************************************
     86           * @fn          nwk_rawSend
     87           *
     88           * @brief       Builds an outut frame based on information provided by the
     89           *              caller. This function allows a raw transmission to the target
     90           *              if the network address is known. this function is used a lot
     91           *              to support NWK applications.
     92           *
     93           * input parameters
     94           * @param   info    - pointer to strcuture containing info on how to build
     95           *                    the outgoing frame.
     96           * output parameters
     97           *
     98           * @return         SMPL_SUCCESS
     99           *                 SMPL_NOMEM       - no room in output frame queue
    100           *                 SMPL_TX_CCA_FAIL - CCA failure
    101           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    102          smplStatus_t nwk_rawSend(ioctlRawSend_t *info)
   \                     nwk_rawSend:
    103          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    104            frameInfo_t *pOutFrame;
    105            uint8_t      hops;
    106          
    107            /* If we know frame is going to or from the AP then we can reduce the hop
    108             * count.
    109             */
    110            switch (info->port)
   \   000009   EE           MOV     A,R6
   \   00000A   2405         ADD     A,#0x5
   \   00000C   F8           MOV     R0,A
   \   00000D   EF           MOV     A,R7
   \   00000E   3400         ADDC    A,#0x0
   \   000010   F9           MOV     R1,A
   \   000011   8882         MOV     DPL,R0
   \   000013   8983         MOV     DPH,R1
   \   000015   E0           MOVX    A,@DPTR
   \   000016   24FD         ADD     A,#-0x3
   \   000018   6007         JZ      ??nwk_rawSend_0
   \   00001A   24FE         ADD     A,#-0x2
   \   00001C   6003         JZ      ??nwk_rawSend_0
   \   00001E   14           DEC     A
   \   00001F   7004         JNZ     ??nwk_rawSend_1
    111            {
    112              case SMPL_PORT_JOIN:
    113              case SMPL_PORT_FREQ:
    114              case SMPL_PORT_MGMT:
    115                hops = MAX_HOPS_FROM_AP;
   \                     ??nwk_rawSend_0:
   \   000021   7D01         MOV     R5,#0x1
    116                break;
   \   000023   8002         SJMP    ??nwk_rawSend_2
    117          
    118              default:
    119                hops = MAX_HOPS;
   \                     ??nwk_rawSend_1:
   \   000025   7D03         MOV     R5,#0x3
    120                break;
    121            }
    122          
    123            if (pOutFrame = nwk_buildFrame(info->port, info->msg, info->len, hops))
   \                     ??nwk_rawSend_2:
   \   000027                ; Setup parameters for call to function nwk_buildFrame
   \   000027   8E82         MOV     DPL,R6
   \   000029   8F83         MOV     DPH,R7
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FC           MOV     R4,A
   \   000031   8E82         MOV     DPL,R6
   \   000033   8F83         MOV     DPH,R7
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   FA           MOV     R2,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   FB           MOV     R3,A
   \   00003C   8882         MOV     DPL,R0
   \   00003E   8983         MOV     DPH,R1
   \   000040   E0           MOVX    A,@DPTR
   \   000041   F9           MOV     R1,A
   \   000042   12....       LCALL   nwk_buildFrame
   \   000045   8A..         MOV     ?V0 + 0,R2
   \   000047   8B..         MOV     ?V0 + 1,R3
   \   000049   A9..         MOV     R1,?V0 + 1
   \   00004B   EA           MOV     A,R2
   \   00004C   49           ORL     A,R1
   \   00004D   6031         JZ      ??nwk_rawSend_3
    124            {
    125              memcpy(MRFI_P_DST_ADDR(&pOutFrame->mrfiPkt), info->addr, NET_ADDR_SIZE);
   \   00004F                ; Setup parameters for call to function memcpy
   \   00004F   75..04       MOV     ?V0 + 2,#0x4
   \   000052   75..00       MOV     ?V0 + 3,#0x0
   \   000055   78..         MOV     R0,#?V0 + 2
   \   000057   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005A   8E82         MOV     DPL,R6
   \   00005C   8F83         MOV     DPH,R7
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   FC           MOV     R4,A
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   FD           MOV     R5,A
   \   000063   EA           MOV     A,R2
   \   000064   2403         ADD     A,#0x3
   \   000066   0A           INC     R2
   \   000067   0A           INC     R2
   \   000068   0A           INC     R2
   \   000069   E9           MOV     A,R1
   \   00006A   3400         ADDC    A,#0x0
   \   00006C   FB           MOV     R3,A
   \   00006D   12....       LCALL   memcpy
   \   000070   7402         MOV     A,#0x2
   \   000072   12....       LCALL   ?DEALLOC_XSTACK8
    126          #ifdef SMPL_SECURE
    127              nwk_setSecureFrame(&pOutFrame->mrfiPkt, info->len, 0);
    128          #endif  /* SMPL_SECURE */
    129              return nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_CCA);
   \   000075                ; Setup parameters for call to function nwk_sendFrame
   \   000075   7901         MOV     R1,#0x1
   \   000077   AA..         MOV     R2,?V0 + 0
   \   000079   AB..         MOV     R3,?V0 + 1
   \   00007B   12....       LCALL   nwk_sendFrame
   \   00007E   8002         SJMP    ??nwk_rawSend_4
    130            }
    131            return SMPL_NOMEM;
   \                     ??nwk_rawSend_3:
   \   000080   7903         MOV     R1,#0x3
   \                     ??nwk_rawSend_4:
   \   000082   7F04         MOV     R7,#0x4
   \   000084   02....       LJMP    ?FUNC_LEAVE_XDATA
    132          }
    133          
    134          /******************************************************************************
    135           * @fn          nwk_rawReceive
    136           *
    137           * @brief       Retriievs specified from from the input frame queue. Additional
    138           *              information such as source address and hop count may also be
    139           *              retrieved
    140           *
    141           * input parameters
    142           * @param   info    - pointer to structure containing info on what to retrieve
    143           *
    144           * output parameters - actually populated by nwk_retrieveFrame()
    145           *      info->msg      - application payload copied here
    146           *      info->len      - length of received application payload
    147           *      info->addr     - if non-NULL points to memory to be populated with
    148           *                       source address of retrieved frame.
    149           *      info->hopCount - if non-NULL points to memory to be populated with
    150           *                       hop count of retrieved frame.
    151           *
    152           * @return   Status of operation.
    153           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    154          smplStatus_t nwk_rawReceive(ioctlRawReceive_t *info)
   \                     nwk_rawReceive:
    155          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    156            rcvContext_t rcv;
    157          
    158            rcv.type   = RCV_NWK_PORT;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
    159            rcv.t.port = info->port;
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   C0E0         PUSH    A
   \   00001E   7401         MOV     A,#0x1
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   D0E0         POP     A
   \   000025   F0           MOVX    @DPTR,A
    160          
    161            return nwk_retrieveFrame(&rcv, info->msg, &info->len, info->addr, &info->hopCount);
   \   000026                ; Setup parameters for call to function nwk_retrieveFrame
   \   000026   EA           MOV     A,R2
   \   000027   2406         ADD     A,#0x6
   \   000029   F5..         MOV     ?V0 + 0,A
   \   00002B   EB           MOV     A,R3
   \   00002C   3400         ADDC    A,#0x0
   \   00002E   F5..         MOV     ?V0 + 1,A
   \   000030   78..         MOV     R0,#?V0 + 0
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000035   8A82         MOV     DPL,R2
   \   000037   8B83         MOV     DPH,R3
   \   000039   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00003C   EA           MOV     A,R2
   \   00003D   2404         ADD     A,#0x4
   \   00003F   F5..         MOV     ?V0 + 0,A
   \   000041   EB           MOV     A,R3
   \   000042   3400         ADDC    A,#0x0
   \   000044   F5..         MOV     ?V0 + 1,A
   \   000046   78..         MOV     R0,#?V0 + 0
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004B   8A82         MOV     DPL,R2
   \   00004D   8B83         MOV     DPH,R3
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   FC           MOV     R4,A
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FD           MOV     R5,A
   \   000056   7406         MOV     A,#0x6
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   AA82         MOV     R2,DPL
   \   00005D   AB83         MOV     R3,DPH
   \   00005F   12....       LCALL   nwk_retrieveFrame
   \   000062   7406         MOV     A,#0x6
   \   000064   12....       LCALL   ?DEALLOC_XSTACK8
   \   000067   7403         MOV     A,#0x3
   \   000069   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006C   7F02         MOV     R7,#0x2
   \   00006E   02....       LJMP    ?FUNC_LEAVE_XDATA
    162          }
    163          
    164          /******************************************************************************
    165           * @fn          nwk_radioControl
    166           *
    167           * @brief       Handle radio control functions.
    168           *
    169           * input parameters
    170           * @param   action   - radio operation to perform. currently suppoerted:
    171           *                         sleep/unsleep
    172           * output parameters
    173           *
    174           * @return   Status of operation.
    175           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    176          smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
   \                     nwk_radioControl:
    177          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 1,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    178            smplStatus_t rc = SMPL_SUCCESS;
   \   00000B   75..00       MOV     ?V0 + 0,#0x0
    179          
    180            if (IOCTL_ACT_RADIO_SLEEP == action)
   \   00000E   7404         MOV     A,#0x4
   \   000010   65..         XRL     A,?V0 + 1
   \   000012   7009         JNZ     ??nwk_radioControl_0
    181            {
    182              /* go to sleep mode. */
    183              MRFI_RxIdle();
   \   000014                ; Setup parameters for call to function MRFI_RxIdle
   \   000014   12....       LCALL   MRFI_RxIdle
    184              MRFI_Sleep();
   \   000017                ; Setup parameters for call to function MRFI_Sleep
   \   000017   12....       LCALL   MRFI_Sleep
   \   00001A   02....       LJMP    ??nwk_radioControl_1
    185            }
    186            else if (IOCTL_ACT_RADIO_AWAKE == action)
   \                     ??nwk_radioControl_0:
   \   00001D   7405         MOV     A,#0x5
   \   00001F   65..         XRL     A,?V0 + 1
   \   000021   7009         JNZ     ??nwk_radioControl_2
    187            {
    188              MRFI_WakeUp();
   \   000023                ; Setup parameters for call to function MRFI_WakeUp
   \   000023   12....       LCALL   MRFI_WakeUp
    189          
    190          #if !defined( END_DEVICE )
    191              MRFI_RxOn();
   \   000026                ; Setup parameters for call to function MRFI_RxOn
   \                     ??nwk_radioControl_3:
   \   000026   12....       LCALL   MRFI_RxOn
   \   000029   02....       LJMP    ??nwk_radioControl_1
    192          #endif
    193          
    194            }
    195            else if (IOCTL_ACT_RADIO_SIGINFO == action)
   \                     ??nwk_radioControl_2:
   \   00002C   7406         MOV     A,#0x6
   \   00002E   65..         XRL     A,?V0 + 1
   \   000030   7037         JNZ     ??nwk_radioControl_4
    196            {
    197              ioctlRadioSiginfo_t *pSigInfo = (ioctlRadioSiginfo_t *)val;
    198              connInfo_t          *pCInfo   = nwk_getConnInfo(pSigInfo->lid);
   \   000032                ; Setup parameters for call to function nwk_getConnInfo
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F9           MOV     R1,A
   \   000038   12....       LCALL   nwk_getConnInfo
    199          
    200              if (!pCInfo)
   \   00003B   EA           MOV     A,R2
   \   00003C   4B           ORL     A,R3
   \   00003D   7004         JNZ     ??nwk_radioControl_5
    201              {
    202                return SMPL_BAD_PARAM;
   \                     ??nwk_radioControl_6:
   \   00003F   7902         MOV     R1,#0x2
   \   000041   8071         SJMP    ??nwk_radioControl_7
    203              }
    204              memcpy(&pSigInfo->sigInfo, &pCInfo->sigInfo, sizeof(pCInfo->sigInfo));
   \                     ??nwk_radioControl_5:
   \   000043                ; Setup parameters for call to function memcpy
   \   000043   75..02       MOV     ?V0 + 2,#0x2
   \   000046   75..00       MOV     ?V0 + 3,#0x0
   \   000049   78..         MOV     R0,#?V0 + 2
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   EA           MOV     A,R2
   \   00004F   2407         ADD     A,#0x7
   \   000051   FC           MOV     R4,A
   \   000052   EB           MOV     A,R3
   \   000053   3400         ADDC    A,#0x0
   \   000055   FD           MOV     R5,A
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   A3           INC     DPTR
   \   00005B   AA82         MOV     R2,DPL
   \   00005D   AB83         MOV     R3,DPH
   \   00005F   12....       LCALL   memcpy
   \   000062   7402         MOV     A,#0x2
   \   000064   12....       LCALL   ?DEALLOC_XSTACK8
   \   000067   8049         SJMP    ??nwk_radioControl_1
    205            }
    206            else if (IOCTL_ACT_RADIO_RSSI == action)
   \                     ??nwk_radioControl_4:
   \   000069   7407         MOV     A,#0x7
   \   00006B   65..         XRL     A,?V0 + 1
   \   00006D   700B         JNZ     ??nwk_radioControl_8
    207            {
    208              *((rssi_t *)val) = MRFI_Rssi();
   \   00006F                ; Setup parameters for call to function MRFI_Rssi
   \   00006F   12....       LCALL   MRFI_Rssi
   \   000072   E9           MOV     A,R1
   \   000073   8E82         MOV     DPL,R6
   \   000075   8F83         MOV     DPH,R7
   \   000077   F0           MOVX    @DPTR,A
   \   000078   8038         SJMP    ??nwk_radioControl_1
    209            }
    210            else if (IOCTL_ACT_RADIO_RXON == action)
   \                     ??nwk_radioControl_8:
   \   00007A   7408         MOV     A,#0x8
   \   00007C   65..         XRL     A,?V0 + 1
   \   00007E   60A6         JZ      ??nwk_radioControl_3
    211            {
    212              MRFI_RxOn();
   \   000080                ; Setup parameters for call to function MRFI_RxOn
    213            }
    214            else if (IOCTL_ACT_RADIO_RXIDLE == action)
   \   000080   7409         MOV     A,#0x9
   \   000082   65..         XRL     A,?V0 + 1
   \   000084   7005         JNZ     ??nwk_radioControl_9
    215            {
    216              MRFI_RxIdle();
   \   000086                ; Setup parameters for call to function MRFI_RxIdle
   \   000086   12....       LCALL   MRFI_RxIdle
   \   000089   8027         SJMP    ??nwk_radioControl_1
    217            }
    218          #ifdef EXTENDED_API
    219            else if (IOCTL_ACT_RADIO_SETPWR == action)
   \                     ??nwk_radioControl_9:
   \   00008B   740A         MOV     A,#0xa
   \   00008D   65..         XRL     A,?V0 + 1
   \   00008F   701E         JNZ     ??nwk_radioControl_10
    220            {
    221              uint8_t idx;
    222          
    223              switch (*(ioctlLevel_t *)val)
   \   000091   8E82         MOV     DPL,R6
   \   000093   8F83         MOV     DPH,R7
   \   000095   E0           MOVX    A,@DPTR
   \   000096   600E         JZ      ??nwk_radioControl_11
   \   000098   14           DEC     A
   \   000099   6007         JZ      ??nwk_radioControl_12
   \   00009B   14           DEC     A
   \   00009C   70A1         JNZ     ??nwk_radioControl_6
    224              {
    225                case IOCTL_LEVEL_2:
    226                  idx = 2;
   \   00009E   7902         MOV     R1,#0x2
    227                  break;
   \   0000A0   8006         SJMP    ??nwk_radioControl_13
    228          
    229                case IOCTL_LEVEL_1:
    230                  idx = 1;
   \                     ??nwk_radioControl_12:
   \   0000A2   7901         MOV     R1,#0x1
    231                  break;
   \   0000A4   8002         SJMP    ??nwk_radioControl_13
    232          
    233                case IOCTL_LEVEL_0:
    234                  idx = 0;
   \                     ??nwk_radioControl_11:
   \   0000A6   7900         MOV     R1,#0x0
    235                  break;
    236          
    237                default:
    238                  return SMPL_BAD_PARAM;
    239              }
    240              MRFI_SetRFPwr(idx);
   \                     ??nwk_radioControl_13:
   \   0000A8                ; Setup parameters for call to function MRFI_SetRFPwr
   \   0000A8   12....       LCALL   MRFI_SetRFPwr
    241              return SMPL_SUCCESS;
   \   0000AB   7900         MOV     R1,#0x0
   \   0000AD   8005         SJMP    ??nwk_radioControl_7
    242            }
    243          #endif  /* EXTENDED_API */
    244            else
    245            {
    246              rc = SMPL_BAD_PARAM;
   \                     ??nwk_radioControl_10:
   \   0000AF   75..02       MOV     ?V0 + 0,#0x2
    247            }
    248            return rc;
   \                     ??nwk_radioControl_1:
   \   0000B2   A9..         MOV     R1,?V0 + 0
   \                     ??nwk_radioControl_7:
   \   0000B4   7F04         MOV     R7,#0x4
   \   0000B6   02....       LJMP    ?FUNC_LEAVE_XDATA
    249          }
    250          
    251          /******************************************************************************
    252           * @fn          nwk_joinContext
    253           *
    254           * @brief       For Access Points we need a way to support changing the Join
    255           *              context. This will allow arbitration bewteen potentially nearby
    256           *              Access Points when a new device is joining.
    257           *
    258           * input parameters
    259           * @param   action  - Join context is either on or off.
    260           *
    261           * output parameters
    262           *
    263           * @return   Status of operation. Currently always succeeds.
    264           */
    265          #ifdef ACCESS_POINT

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    266          smplStatus_t nwk_joinContext(ioctlAction_t action)
   \                     nwk_joinContext:
    267          {
   \   000000   EE           MOV     A,R6
   \   000001   C0E0         PUSH    A
   \   000003                ; Saved register size: 1
   \   000003                ; Auto size: 0
   \   000003   E9           MOV     A,R1
   \   000004   FE           MOV     R6,A
    268            nwk_setJoinContext((IOCTL_ACT_ON == action) ? JOIN_CONTEXT_ON : JOIN_CONTEXT_OFF);
   \   000005   740B         MOV     A,#0xb
   \   000007   6E           XRL     A,R6
   \   000008   7004         JNZ     ??nwk_joinContext_0
   \   00000A   7901         MOV     R1,#0x1
   \   00000C   8002         SJMP    ??nwk_joinContext_1
   \                     ??nwk_joinContext_0:
   \   00000E   7902         MOV     R1,#0x2
   \                     ??nwk_joinContext_1:
   \   000010                ; Setup parameters for call to function nwk_setJoinContext
   \   000010   12....       LCALL   nwk_setJoinContext
    269          
    270            return SMPL_SUCCESS;
   \   000013   7900         MOV     R1,#0x0
   \   000015   D0E0         POP     A
   \   000017   FE           MOV     R6,A
   \   000018   22           RET
    271          }
    272          #endif
    273          
    274          /******************************************************************************
    275           * @fn          nwk_deviceAddress
    276           *
    277           * @brief       Set or Get this device address. The Set must be done before
    278           *              SMPL_Init() for it to take effect. The Get is always legal but
    279           *              the value could be invalid if it is called before a valid set
    280           *              call is made.
    281           *
    282           * input parameters
    283           * @param   action  - Gte or Set
    284           * @param   addr    - pointer to address object containing value on Set
    285           *
    286           * output parameters
    287           * @param   addr    - pointer to address object to receive value on Get.
    288           *
    289           * @return   SMPL_SUCCESS
    290           *           SMPL_BAD_PARAM  Action request illegal or a Set request
    291           *                           was not respected.
    292           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    293          smplStatus_t nwk_deviceAddress(ioctlAction_t action, addr_t *addr)
   \                     nwk_deviceAddress:
    294          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 1,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    295            smplStatus_t rc = SMPL_BAD_PARAM;
   \   00000B   75..02       MOV     ?V0 + 0,#0x2
    296          
    297            if (IOCTL_ACT_GET == action)
   \   00000E   7401         MOV     A,#0x1
   \   000010   65..         XRL     A,?V0 + 1
   \   000012   7020         JNZ     ??nwk_deviceAddress_0
    298            {
    299              memcpy(addr, nwk_getMyAddress(), sizeof(addr_t));
   \   000014                ; Setup parameters for call to function memcpy
   \   000014   75..04       MOV     ?V0 + 2,#0x4
   \   000017   75..00       MOV     ?V0 + 3,#0x0
   \   00001A   78..         MOV     R0,#?V0 + 2
   \   00001C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001F                ; Setup parameters for call to function nwk_getMyAddress
   \   00001F   12....       LCALL   nwk_getMyAddress
   \   000022   EA           MOV     A,R2
   \   000023   FC           MOV     R4,A
   \   000024   EB           MOV     A,R3
   \   000025   FD           MOV     R5,A
   \   000026   EE           MOV     A,R6
   \   000027   FA           MOV     R2,A
   \   000028   EF           MOV     A,R7
   \   000029   FB           MOV     R3,A
   \   00002A   12....       LCALL   memcpy
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
    300              rc = SMPL_SUCCESS;
   \   000032   8009         SJMP    ??nwk_deviceAddress_1
    301            }
    302            else if (IOCTL_ACT_SET == action)
   \                     ??nwk_deviceAddress_0:
   \   000034   E9           MOV     A,R1
   \   000035   7009         JNZ     ??nwk_deviceAddress_2
    303            {
    304              if (nwk_setMyAddress(addr))
   \   000037                ; Setup parameters for call to function nwk_setMyAddress
   \   000037   12....       LCALL   nwk_setMyAddress
   \   00003A   E9           MOV     A,R1
   \   00003B   6003         JZ      ??nwk_deviceAddress_2
    305              {
    306                rc = SMPL_SUCCESS;
   \                     ??nwk_deviceAddress_1:
   \   00003D   75..00       MOV     ?V0 + 0,#0x0
    307              }
    308            }
    309          
    310            return rc;
   \                     ??nwk_deviceAddress_2:
   \   000040   A9..         MOV     R1,?V0 + 0
   \   000042   7F04         MOV     R7,#0x4
   \   000044   02....       LJMP    ?FUNC_LEAVE_XDATA
    311          }
    312          
    313          /******************************************************************************
    314           * @fn          nwk_connectionControl
    315           *
    316           * @brief       Access to connection table. Currently supports only deleting
    317           *              a connection from the table.
    318           *
    319           * input parameters
    320           * @param   action  - Connection control action (only delete is curently valid).
    321           * @param   val     - pointer to Link ID of connection on which to operate.
    322           *
    323           * output parameters
    324           *
    325           * @return   SMPL_SUCCESS
    326           *           SMPL_BAD_PARAM  Action is not delete
    327           *                           Link ID is the UUD Link ID
    328           *                           No connection table info for Link ID
    329           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    330          smplStatus_t nwk_connectionControl(ioctlAction_t action, void *val)
   \                     nwk_connectionControl:
    331          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    332            connInfo_t *pCInfo;
    333            linkID_t    lid = *((linkID_t *)val);
   \   000007   8A82         MOV     DPL,R2
   \   000009   8B83         MOV     DPH,R3
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
    334          
    335            if (IOCTL_ACT_DELETE != action)
   \   00000D   740E         MOV     A,#0xe
   \   00000F   6E           XRL     A,R6
   \   000010   6004         JZ      ??nwk_connectionControl_0
    336            {
    337              return SMPL_BAD_PARAM;
   \                     ??nwk_connectionControl_1:
   \   000012   7902         MOV     R1,#0x2
   \   000014   8011         SJMP    ??nwk_connectionControl_2
    338            }
    339          
    340            if ((SMPL_LINKID_USER_UUD == lid) ||
    341                (!(pCInfo=nwk_getConnInfo(lid))))
   \                     ??nwk_connectionControl_0:
   \   000016   74FF         MOV     A,#-0x1
   \   000018   69           XRL     A,R1
   \   000019   60F7         JZ      ??nwk_connectionControl_1
   \   00001B                ; Setup parameters for call to function nwk_getConnInfo
   \   00001B   12....       LCALL   nwk_getConnInfo
   \   00001E   EA           MOV     A,R2
   \   00001F   4B           ORL     A,R3
   \   000020   60F0         JZ      ??nwk_connectionControl_1
    342            {
    343              return SMPL_BAD_PARAM;
    344            }
    345          
    346            nwk_freeConnection(pCInfo);
   \   000022                ; Setup parameters for call to function nwk_freeConnection
   \   000022   12....       LCALL   nwk_freeConnection
    347          
    348            return SMPL_SUCCESS;
   \   000025   7900         MOV     R1,#0x0
   \                     ??nwk_connectionControl_2:
   \   000027   7F02         MOV     R7,#0x2
   \   000029   02....       LJMP    ?FUNC_LEAVE_XDATA
    349          }

   Maximum stack usage in bytes:

     Function                ISTACK PSTACK XSTACK
     --------                ------ ------ ------
     nwk_connectionControl       0      0      9
       -> nwk_getConnInfo        0      0     18
       -> nwk_freeConnection     0      0     18
     nwk_deviceAddress           0      0     13
       -> nwk_getMyAddress       0      0     26
       -> memcpy                 0      0     26
       -> nwk_setMyAddress       0      0     22
     nwk_joinContext             1      0      0
       -> nwk_setJoinContext     2      0      0
     nwk_radioControl            1      0     13
       -> MRFI_RxIdle            0      0     22
       -> MRFI_Sleep             0      0     22
       -> MRFI_WakeUp            0      0     22
       -> MRFI_RxOn              0      0     22
       -> nwk_getConnInfo        0      0     22
       -> memcpy                 0      0     26
       -> MRFI_Rssi              0      0     22
       -> MRFI_RxOn              0      0     22
       -> MRFI_RxIdle            0      0     22
       -> MRFI_SetRFPwr          0      0     22
     nwk_rawReceive              1      0     18
       -> nwk_retrieveFrame      0      0     36
     nwk_rawSend                 0      0     13
       -> nwk_buildFrame         0      0     22
       -> memcpy                 0      0     26
       -> nwk_sendFrame          0      0     22


   Segment part sizes:

     Function/Label        Bytes
     --------------        -----
     nwk_rawSend            135
     nwk_rawReceive         113
     nwk_radioControl       185
     nwk_joinContext         25
     nwk_deviceAddress       71
     nwk_connectionControl   44

 
 573 bytes in segment NEAR_CODE
 
 573 bytes of CODE memory

Errors: none
Warnings: none
