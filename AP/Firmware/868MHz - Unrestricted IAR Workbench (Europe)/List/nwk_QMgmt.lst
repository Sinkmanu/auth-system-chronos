###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.40338/W32 for 8051         26/Nov/2012  10:49:36 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  near                                               #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Documents and Settings\usuario\Mis              #
#                          documentos\Server_IAR\simpliciti\Components\nwk\nw #
#                          k_QMgmt.c                                          #
#    Command line       =  -f "C:\Documents and Settings\usuario\Mis          #
#                          documentos\Server_IAR\simpliciti\Configuration\Acc #
#                          ess Point\smpl_config.dat" (-DNUM_CONNECTIONS=1    #
#                          -DSIZE_INFRAME_Q=6 -DSIZE_OUTFRAME_Q=2             #
#                          "-DTHIS_DEVICE_ADDRESS={0x78, 0x56, 0x34, 0x10}"   #
#                          -DACCESS_POINT -DAP_IS_DATA_HUB                    #
#                          -DNUM_STORE_AND_FWD_CLIENTS=3                      #
#                          -DSTARTUP_JOINCONTEXT_ON) -f "C:\Documents and     #
#                          Settings\usuario\Mis documentos\Server_IAR\simplic #
#                          iti\Configuration\smpl_nwk_config.dat"             #
#                          (-DMAX_HOPS=3 -DMAX_HOPS_FROM_AP=1                 #
#                          -DMAX_NWK_PAYLOAD=9 -DMAX_APP_PAYLOAD=19           #
#                          -DDEFAULT_LINK_TOKEN=0x01020304                    #
#                          -DDEFAULT_JOIN_TOKEN=0x05060708 -DAPP_AUTO_ACK     #
#                          -DEXTENDED_API -DxSMPL_SECURE -DxNVOBJECT_SUPPORT  #
#                          -DxSW_TIMER) "C:\Documents and                     #
#                          Settings\usuario\Mis documentos\Server_IAR\simplic #
#                          iti\Components\nwk\nwk_QMgmt.c" -D CC1111EM -D     #
#                          ISM_EU -D MCU_H=<ioCC1111.h> -D chip=1111 -D       #
#                          RF_FREQUENCY=868000 -D MRFI_CC1111 -D NDEBUG -lC   #
#                          "C:\Documents and Settings\usuario\Mis             #
#                          documentos\Server_IAR\868MHz - Unrestricted IAR    #
#                          Workbench (Europe)\List\" -o "C:\Documents and     #
#                          Settings\usuario\Mis documentos\Server_IAR\868MHz  #
#                          - Unrestricted IAR Workbench (Europe)\Obj\" -e     #
#                          --no_unroll --no_inline --no_tbaa --debug          #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=near --calling_convention=xdata_reent #
#                          rant --place_constants=data --nr_virtual_regs 8    #
#                          -I "C:\Documents and Settings\usuario\Mis          #
#                          documentos\Server_IAR\bm-br1\" -I "C:\Documents    #
#                          and Settings\usuario\Mis                           #
#                          documentos\Server_IAR\HAL\include\" -I             #
#                          "C:\Documents and Settings\usuario\Mis             #
#                          documentos\Server_IAR\HAL\source\" -I              #
#                          "C:\Documents and Settings\usuario\Mis             #
#                          documentos\Server_IAR\wbsl\" -I "C:\Documents and  #
#                          Settings\usuario\Mis documentos\Server_IAR\usb\"   #
#                          -I "C:\Documents and Settings\usuario\Mis          #
#                          documentos\Server_IAR\usb\class_cdc\" -I           #
#                          "C:\Documents and Settings\usuario\Mis             #
#                          documentos\Server_IAR\usb\library\" -I             #
#                          "C:\Documents and Settings\usuario\Mis             #
#                          documentos\Server_IAR\usb\library\ccxx11\" -I      #
#                          "C:\Documents and Settings\usuario\Mis             #
#                          documentos\Server_IAR\sync\" -I "C:\Documents and  #
#                          Settings\usuario\Mis documentos\Server_IAR\simplic #
#                          iti\" -I "C:\Documents and Settings\usuario\Mis    #
#                          documentos\Server_IAR\simpliciti\Components\bsp\"  #
#                          -I "C:\Documents and Settings\usuario\Mis          #
#                          documentos\Server_IAR\simpliciti\Components\bsp\dr #
#                          ivers\" -I "C:\Documents and Settings\usuario\Mis  #
#                          documentos\Server_IAR\simpliciti\Components\bsp\bo #
#                          ards\RFUSB\" -I "C:\Documents and                  #
#                          Settings\usuario\Mis documentos\Server_IAR\simplic #
#                          iti\Components\mrfi\" -I "C:\Documents and         #
#                          Settings\usuario\Mis documentos\Server_IAR\simplic #
#                          iti\Components\nwk\" -I "C:\Documents and          #
#                          Settings\usuario\Mis documentos\Server_IAR\simplic #
#                          iti\Components\nwk_applications\" -Om              #
#    List file          =  C:\Documents and Settings\usuario\Mis              #
#                          documentos\Server_IAR\868MHz - Unrestricted IAR    #
#                          Workbench (Europe)\List\nwk_QMgmt.lst              #
#    Object file        =  C:\Documents and Settings\usuario\Mis              #
#                          documentos\Server_IAR\868MHz - Unrestricted IAR    #
#                          Workbench (Europe)\Obj\nwk_QMgmt.r51               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\usuario\Mis documentos\Server_IAR\simpliciti\Components\nwk\nwk_QMgmt.c
      1          /**************************************************************************************************
      2            Filename:       nwk_QMgmt.c
      3            Revised:        $Date: 2009-03-10 17:01:56 -0700 (Tue, 10 Mar 2009) $
      4            Revision:       $Revision: 19372 $
      5            Author:         $Author: lfriedman $
      6          
      7            Description:    This file supports the SimpliciTI input and output frame queues
      8          
      9            Copyright 2007-2008 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights granted under
     12            the terms of a software license agreement between the user who downloaded the software,
     13            his/her employer (which must be your employer) and Texas Instruments Incorporated (the
     14            "License"). You may not use this Software unless you agree to abide by the terms of the
     15            License. The License limits your use, and you acknowledge, that the Software may not be
     16            modified, copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio frequency
     18            transceiver, which is integrated into your product. Other than for the foregoing purpose,
     19            you may not use, reproduce, copy, prepare derivative works of, modify, distribute,
     20            perform, display or sell this Software and/or its documentation for any purpose.
     21          
     22            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS”
     23            WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY
     24            WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
     25            IN NO EVENT SHALL TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     26            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE
     27            THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY
     28            INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST
     29            DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY
     30            THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     31          
     32            Should you have any questions regarding your right to use this Software,
     33            contact Texas Instruments Incorporated at www.TI.com.
     34          **************************************************************************************************/
     35          
     36          
     37          /******************************************************************************
     38           * INCLUDES
     39           */
     40          #include <intrinsics.h>
     41          #include <string.h>
     42          #include "bsp.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     43          #include "mrfi.h"
     44          #include "nwk_types.h"
     45          #include "nwk.h"
     46          #include "nwk_frame.h"
     47          #include "nwk_QMgmt.h"
     48          #include "nwk_mgmt.h"     /* need offsets for poll frames */
     49          
     50          /******************************************************************************
     51           * MACROS
     52           */
     53          
     54          /******************************************************************************
     55           * CONSTANTS AND DEFINES
     56           */
     57          
     58          /******************************************************************************
     59           * TYPEDEFS
     60           */
     61          
     62          /******************************************************************************
     63           * LOCAL VARIABLES
     64           */
     65          
     66          #if SIZE_INFRAME_Q > 0

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     67          static frameInfo_t   sInFrameQ[SIZE_INFRAME_Q];
   \                     sInFrameQ:
   \   000000                DS 210
   \   0000D2                REQUIRE __INIT_XDATA_Z
     68          #else
     69          static frameInfo_t  *sInFrameQ = NULL;
     70          #endif  /* SIZE_INFRAME_Q > 0 */
     71          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     72          static frameInfo_t   sOutFrameQ[SIZE_OUTFRAME_Q];
   \                     sOutFrameQ:
   \   000000                DS 70
   \   000046                REQUIRE __INIT_XDATA_Z
     73          
     74          /******************************************************************************
     75           * LOCAL FUNCTIONS
     76           */
     77          
     78          /******************************************************************************
     79           * GLOBAL VARIABLES
     80           */
     81          
     82          /******************************************************************************
     83           * GLOBAL FUNCTIONS
     84           */
     85          
     86          /******************************************************************************
     87          * @fn          nwk_QInit
     88          * 
     89          * @brief     Initialize the input and output frame queues to hold no packets. 
     90          * 
     91          * input parameters
     92          * 
     93          * output parameters
     94          * 
     95          * @return   void
     96          */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
     97          void nwk_QInit(void)
   \                     nwk_QInit:
     98          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
     99          #if SIZE_INFRAME_Q > 0
    100            memset(sInFrameQ, 0, sizeof(sInFrameQ));
   \   000005                ; Setup parameters for call to function memset
   \   000005   75..D2       MOV     ?V0 + 0,#-0x2e
   \   000008   75..00       MOV     ?V0 + 1,#0x0
   \   00000B   78..         MOV     R0,#?V0 + 0
   \   00000D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000010   7C00         MOV     R4,#0x0
   \   000012   7D00         MOV     R5,#0x0
   \   000014   7A..         MOV     R2,#sInFrameQ & 0xff
   \   000016   7B..         MOV     R3,#(sInFrameQ >> 8) & 0xff
   \   000018   12....       LCALL   memset
   \   00001B   7402         MOV     A,#0x2
   \   00001D   12....       LCALL   ?DEALLOC_XSTACK8
    101          #endif  // SIZE_INFRAME_Q > 0
    102            memset(sOutFrameQ, 0, sizeof(sOutFrameQ));
   \   000020                ; Setup parameters for call to function memset
   \   000020   75..46       MOV     ?V0 + 0,#0x46
   \   000023   78..         MOV     R0,#?V0 + 0
   \   000025   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000028   7C00         MOV     R4,#0x0
   \   00002A   7D00         MOV     R5,#0x0
   \   00002C   7A..         MOV     R2,#sOutFrameQ & 0xff
   \   00002E   7B..         MOV     R3,#(sOutFrameQ >> 8) & 0xff
   \   000030   12....       LCALL   memset
   \   000033   7402         MOV     A,#0x2
   \   000035   12....       LCALL   ?DEALLOC_XSTACK8
    103          }
   \   000038   7F02         MOV     R7,#0x2
   \   00003A   02....       LJMP    ?FUNC_LEAVE_XDATA
    104           
    105          /******************************************************************************
    106           * @fn          nwk_QfindSlot
    107           *
    108           * @brief       Finds a slot to use to retrieve the frame from the radio. It
    109           *              uses a LRU cast-out scheme. It is possible that this routine
    110           *              finds no slot. This can happen if the queue is of size 1 or 2
    111           *              and the Rx interrupt occurs during a retrieval call from an
    112           *              application. There are meta-states for frames as the application
    113           *              looks for the oldest frame on the port being requested.
    114           *
    115           *              This routine is running in interrupt context.
    116           *
    117           * input parameters
    118           * @param   which   - INQ or OUTQ to search
    119           *
    120           * output parameters
    121           *
    122           * @return      Pointer to oldest available frame in the queue
    123           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    124          frameInfo_t *nwk_QfindSlot(uint8_t which)
   \                     nwk_QfindSlot:
    125          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
    126            frameInfo_t *pFI, *oldest= 0, *newFI = 0;
   \   000007   7800         MOV     R0,#0x0
   \   000009   7900         MOV     R1,#0x0
   \   00000B   7E00         MOV     R6,#0x0
   \   00000D   7F00         MOV     R7,#0x0
    127            uint8_t        i, num, newOrder = 0, orderTest;
   \   00000F   7C00         MOV     R4,#0x0
    128          
    129            if (INQ == which)
   \   000011   7401         MOV     A,#0x1
   \   000013   65..         XRL     A,?V0 + 0
   \   000015   7008         JNZ     ??nwk_QfindSlot_0
    130            {
    131              pFI  = sInFrameQ;
   \   000017   7A..         MOV     R2,#sInFrameQ & 0xff
   \   000019   7B..         MOV     R3,#(sInFrameQ >> 8) & 0xff
    132              num  = SIZE_INFRAME_Q;
   \   00001B   7D06         MOV     R5,#0x6
   \   00001D   8006         SJMP    ??nwk_QfindSlot_1
    133            }
    134            else
    135            {
    136              pFI  = sOutFrameQ;
   \                     ??nwk_QfindSlot_0:
   \   00001F   7A..         MOV     R2,#sOutFrameQ & 0xff
   \   000021   7B..         MOV     R3,#(sOutFrameQ >> 8) & 0xff
    137              num  = SIZE_OUTFRAME_Q;
   \   000023   7D02         MOV     R5,#0x2
    138            }
    139          
    140            orderTest = num + 1;
   \                     ??nwk_QfindSlot_1:
   \   000025   7401         MOV     A,#0x1
   \   000027   2D           ADD     A,R5
   \   000028   F5..         MOV     ?V0 + 2,A
    141          
    142            for (i=0; i<num; ++i, ++pFI)
   \   00002A   88..         MOV     ?V0 + 1,R0
   \   00002C   800E         SJMP    ??nwk_QfindSlot_2
    143            {
    144              /* if frame is available it's a candidate. */
    145              if (pFI->fi_usage != FI_AVAILABLE)
    146              {
    147                if (INQ == which)  /* TODO: do cast-out for Tx as well */
    148                {
    149          
    150                  /* need to know the number of occupied slots so we know the age value
    151                   * for the unoccupied slot (if there is one).
    152                   */
    153                  newOrder++;
    154          
    155                  /* make sure nwk_retrieveFrame() is not processing this frame */
    156                  if (FI_INUSE_TRANSITION == pFI->fi_usage)
    157                  {
    158                    continue;
    159                  }
    160                  /* is this frame older than any we've seen? */
    161                  if (orderTest > pFI->orderStamp)
    162                  {
    163                    /* yes. */
    164                    oldest    = pFI;
    165                    orderTest = pFI->orderStamp;
    166                  }
    167                }
    168              }
    169              else
    170              {
    171                if (OUTQ == which)  /* TODO: do cast-out for Tx as well */
    172                {
    173                  return pFI;
    174                }
    175                newFI = pFI;
   \                     ??nwk_QfindSlot_3:
   \   00002E   EA           MOV     A,R2
   \   00002F   FE           MOV     R6,A
   \   000030   EB           MOV     A,R3
   \   000031   FF           MOV     R7,A
   \                     ??nwk_QfindSlot_4:
   \   000032   05..         INC     ?V0 + 1
   \   000034   EA           MOV     A,R2
   \   000035   2423         ADD     A,#0x23
   \   000037   FA           MOV     R2,A
   \   000038   EB           MOV     A,R3
   \   000039   3400         ADDC    A,#0x0
   \   00003B   FB           MOV     R3,A
   \                     ??nwk_QfindSlot_2:
   \   00003C   E5..         MOV     A,?V0 + 1
   \   00003E   C3           CLR     C
   \   00003F   9D           SUBB    A,R5
   \   000040   502B         JNC     ??nwk_QfindSlot_5
   \   000042   8A82         MOV     DPL,R2
   \   000044   8B83         MOV     DPH,R3
   \   000046   E0           MOVX    A,@DPTR
   \   000047   601C         JZ      ??nwk_QfindSlot_6
   \   000049   7401         MOV     A,#0x1
   \   00004B   65..         XRL     A,?V0 + 0
   \   00004D   70E3         JNZ     ??nwk_QfindSlot_4
   \   00004F   0C           INC     R4
   \   000050   E0           MOVX    A,@DPTR
   \   000051   6404         XRL     A,#0x4
   \   000053   60DD         JZ      ??nwk_QfindSlot_4
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   C3           CLR     C
   \   000058   95..         SUBB    A,?V0 + 2
   \   00005A   50D6         JNC     ??nwk_QfindSlot_4
   \   00005C   EA           MOV     A,R2
   \   00005D   F8           MOV     R0,A
   \   00005E   EB           MOV     A,R3
   \   00005F   F9           MOV     R1,A
   \   000060   E0           MOVX    A,@DPTR
   \   000061   F5..         MOV     ?V0 + 2,A
   \   000063   80CD         SJMP    ??nwk_QfindSlot_4
   \                     ??nwk_QfindSlot_6:
   \   000065   7402         MOV     A,#0x2
   \   000067   65..         XRL     A,?V0 + 0
   \   000069   70C3         JNZ     ??nwk_QfindSlot_3
   \   00006B   802F         SJMP    ??nwk_QfindSlot_7
    176              }
    177            }
    178          
    179            /* did we find anything? */
    180            if (!newFI)
   \                     ??nwk_QfindSlot_5:
   \   00006D   EE           MOV     A,R6
   \   00006E   4F           ORL     A,R7
   \   00006F   701E         JNZ     ??nwk_QfindSlot_8
    181            {
    182              /* queue was full. cast-out happens here...unless... */
    183              if (!oldest)
   \   000071   E8           MOV     A,R0
   \   000072   49           ORL     A,R1
   \   000073   7006         JNZ     ??nwk_QfindSlot_9
    184              {
    185                /* This can happen if the queue is only of size 1 or 2 and all
    186                 * the frames are in transition when the Rx interrupt occurs.
    187                 */
    188                return (frameInfo_t *)0;
   \   000075   7A00         MOV     R2,#0x0
   \   000077   7B00         MOV     R3,#0x0
   \   000079   8021         SJMP    ??nwk_QfindSlot_7
    189              }
    190              newFI = oldest;
   \                     ??nwk_QfindSlot_9:
   \   00007B   E8           MOV     A,R0
   \   00007C   FE           MOV     R6,A
   \   00007D   E9           MOV     A,R1
   \   00007E   FF           MOV     R7,A
    191              nwk_QadjustOrder(which, newFI->orderStamp);
   \   00007F   8E82         MOV     DPL,R6
   \   000081   8F83         MOV     DPH,R7
   \   000083   A3           INC     DPTR
   \   000084                ; Setup parameters for call to function nwk_QadjustOrder
   \   000084   E0           MOVX    A,@DPTR
   \   000085   FA           MOV     R2,A
   \   000086   A9..         MOV     R1,?V0 + 0
   \   000088   12....       LCALL   nwk_QadjustOrder
    192              newFI->orderStamp = i;
   \   00008B   E5..         MOV     A,?V0 + 1
   \   00008D   8008         SJMP    ??nwk_QfindSlot_10
    193            }
    194            else
    195            {
    196              /* mark the available slot. */
    197              newFI->orderStamp = ++newOrder;
   \                     ??nwk_QfindSlot_8:
   \   00008F   7401         MOV     A,#0x1
   \   000091   2C           ADD     A,R4
   \   000092   8E82         MOV     DPL,R6
   \   000094   8F83         MOV     DPH,R7
   \   000096   A3           INC     DPTR
   \                     ??nwk_QfindSlot_10:
   \   000097   F0           MOVX    @DPTR,A
    198            }
    199          
    200            return newFI;
   \   000098   EE           MOV     A,R6
   \   000099   FA           MOV     R2,A
   \   00009A   EF           MOV     A,R7
   \   00009B   FB           MOV     R3,A
   \                     ??nwk_QfindSlot_7:
   \   00009C   7F04         MOV     R7,#0x4
   \   00009E   02....       LJMP    ?FUNC_LEAVE_XDATA
    201          }
    202          
    203          /******************************************************************************
    204           * @fn          nwk_QadjustOrder
    205           *
    206           * @brief       Adjusts the age of everyone in the queue newer than the frame
    207           *              being removed.
    208           *
    209           * input parameters
    210           * @param   which   - INQ or OUTQ to adjust
    211           * @param   stamp   - value of frame being removed
    212           *
    213           * output parameters
    214           *
    215           * @return      void
    216           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    217          void nwk_QadjustOrder(uint8_t which, uint8_t stamp)
   \                     nwk_QadjustOrder:
    218          {
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FB           MOV     R3,A
    219            frameInfo_t *pFI;
    220            uint8_t      i, num;
    221            bspIState_t  intState;
    222          
    223            if (INQ == which)
   \   000007   7401         MOV     A,#0x1
   \   000009   6B           XRL     A,R3
   \   00000A   7035         JNZ     ??nwk_QadjustOrder_0
    224            {
    225              pFI  = sInFrameQ;
   \   00000C   78..         MOV     R0,#sInFrameQ & 0xff
   \   00000E   79..         MOV     R1,#(sInFrameQ >> 8) & 0xff
    226              num  = SIZE_INFRAME_Q;
    227            }
    228            else
    229            {
    230          /*    pFI  = sOutFrameQ; */
    231          /*    num  = SIZE_OUTFRAME_Q; */
    232              return;
    233            }
    234          
    235            BSP_ENTER_CRITICAL_SECTION(intState);
   \   000010   A2AF         MOV     C,0xa8.7
   \   000012   E4           CLR     A
   \   000013   33           RLC     A
   \   000014   FE           MOV     R6,A
   \   000015   C2AF         CLR     0xa8.7
    236          
    237            for (i=0; i<num; ++i, ++pFI)
   \   000017   7C00         MOV     R4,#0x0
   \   000019   801B         SJMP    ??nwk_QadjustOrder_1
    238            {
    239              if ((pFI->fi_usage != FI_AVAILABLE) && (pFI->orderStamp > stamp))
   \                     ??nwk_QadjustOrder_2:
   \   00001B   8882         MOV     DPL,R0
   \   00001D   8983         MOV     DPH,R1
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   600B         JZ      ??nwk_QadjustOrder_3
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   FD           MOV     R5,A
   \   000025   EA           MOV     A,R2
   \   000026   C3           CLR     C
   \   000027   9D           SUBB    A,R5
   \   000028   5003         JNC     ??nwk_QadjustOrder_3
    240              {
    241                pFI->orderStamp--;
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   14           DEC     A
   \   00002C   F0           MOVX    @DPTR,A
    242              }
    243            }
   \                     ??nwk_QadjustOrder_3:
   \   00002D   0C           INC     R4
   \   00002E   E8           MOV     A,R0
   \   00002F   2423         ADD     A,#0x23
   \   000031   F8           MOV     R0,A
   \   000032   E9           MOV     A,R1
   \   000033   3400         ADDC    A,#0x0
   \   000035   F9           MOV     R1,A
   \                     ??nwk_QadjustOrder_1:
   \   000036   EC           MOV     A,R4
   \   000037   C3           CLR     C
   \   000038   9406         SUBB    A,#0x6
   \   00003A   40DF         JC      ??nwk_QadjustOrder_2
    244          
    245            BSP_EXIT_CRITICAL_SECTION(intState);
   \   00003C   EE           MOV     A,R6
   \   00003D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00003F   92AF         MOV     0xa8.7,C
    246          
    247            return;
   \                     ??nwk_QadjustOrder_0:
   \   000041   7F01         MOV     R7,#0x1
   \   000043   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   000046                REQUIRE _A_IEN0
    248          }
    249          
    250          /******************************************************************************
    251           * @fn          nwk_QfindOldest
    252           *
    253           * @brief       Look through frame queue and find the oldest available frame
    254           *              in the context in question. Supports connection-based (user),
    255           *              non-connection based (NWK applications), and the special case
    256           *              of store-and-forward.
    257           *
    258           * input parameters
    259           * @param   which      - INQ or OUTQ to adjust
    260           * @param   rcvContext - context information for finding the oldest
    261           * @param   usage      - normal usage or store-and-forward usage
    262           *
    263           * output parameters
    264           *
    265           * @return      Pointer to frame that is the oldsest on the requested port, or
    266           *              0 if there are none.
    267           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    268          frameInfo_t *nwk_QfindOldest(uint8_t which, rcvContext_t *rcv, uint8_t fi_usage)
   \                     nwk_QfindOldest:
    269          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   C0E0         PUSH    A
   \   00000D   740B         MOV     A,#0xb
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   D0E0         POP     A
   \   000014   F0           MOVX    @DPTR,A
   \   000015   EC           MOV     A,R4
   \   000016   C0E0         PUSH    A
   \   000018   740A         MOV     A,#0xa
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   D0E0         POP     A
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   8A..         MOV     ?V0 + 2,R2
   \   000022   8B..         MOV     ?V0 + 3,R3
    270            uint8_t      i, oldest, num, port;
    271            uint8_t      uType, addr12Compare;
    272            bspIState_t  intState;
    273            frameInfo_t *fPtr = 0, *wPtr;
   \   000024   7406         MOV     A,#0x6
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   E4           CLR     A
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   F0           MOVX    @DPTR,A
    274            connInfo_t  *pCInfo = 0;
   \   00002D   85..82       MOV     DPL,?XSP + 0
   \   000030   85..83       MOV     DPH,?XSP + 1
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   F0           MOVX    @DPTR,A
    275            uint8_t     *pAddr1, *pAddr2, *pAddr3 = 0;
   \   000036   7402         MOV     A,#0x2
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   E4           CLR     A
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   A3           INC     DPTR
   \   00003E   F0           MOVX    @DPTR,A
    276          
    277            if (INQ == which)
   \   00003F   740B         MOV     A,#0xb
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   E0           MOVX    A,@DPTR
   \   000045   6401         XRL     A,#0x1
   \   000047   7030         JNZ     ??nwk_QfindOldest_0
    278            {
    279              wPtr   = sInFrameQ;
   \   000049   7E..         MOV     R6,#sInFrameQ & 0xff
   \   00004B   7F..         MOV     R7,#(sInFrameQ >> 8) & 0xff
    280              num    = SIZE_INFRAME_Q;
    281              oldest = SIZE_INFRAME_Q+1;
   \   00004D   75..07       MOV     ?V0 + 6,#0x7
    282            }
    283            else
    284            {
    285          /*    pFI  = sOutFrameQ; */
    286          /*    num  = SIZE_OUTFRAME_Q; */
    287              return 0;
    288            }
    289          
    290            if (RCV_APP_LID == rcv->type)
   \   000050   8A82         MOV     DPL,R2
   \   000052   8B83         MOV     DPH,R3
   \   000054   E0           MOVX    A,@DPTR
   \   000055   6401         XRL     A,#0x1
   \   000057   7054         JNZ     ??nwk_QfindOldest_1
    291            {
    292              pCInfo = nwk_getConnInfo(rcv->t.lid);
   \   000059                ; Setup parameters for call to function nwk_getConnInfo
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F9           MOV     R1,A
   \   00005C   12....       LCALL   nwk_getConnInfo
   \   00005F   85..82       MOV     DPL,?XSP + 0
   \   000062   85..83       MOV     DPH,?XSP + 1
   \   000065   EA           MOV     A,R2
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   EB           MOV     A,R3
   \   000069   F0           MOVX    @DPTR,A
    293              if (!pCInfo)
   \   00006A   85..82       MOV     DPL,?XSP + 0
   \   00006D   85..83       MOV     DPH,?XSP + 1
   \   000070   E0           MOVX    A,@DPTR
   \   000071   F8           MOV     R0,A
   \   000072   A3           INC     DPTR
   \   000073   E0           MOVX    A,@DPTR
   \   000074   F9           MOV     R1,A
   \   000075   E8           MOV     A,R0
   \   000076   49           ORL     A,R1
   \   000077   7007         JNZ     ??nwk_QfindOldest_2
   \                     ??nwk_QfindOldest_0:
   \   000079   7A00         MOV     R2,#0x0
   \   00007B   7B00         MOV     R3,#0x0
   \   00007D   02....       LJMP    ??nwk_QfindOldest_3
    294              {
    295                return (frameInfo_t *)0;
    296              }
    297              port   = pCInfo->portRx;
   \                     ??nwk_QfindOldest_2:
   \   000080   85..82       MOV     DPL,?XSP + 0
   \   000083   85..83       MOV     DPH,?XSP + 1
   \   000086   E0           MOVX    A,@DPTR
   \   000087   F8           MOV     R0,A
   \   000088   A3           INC     DPTR
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   F583         MOV     DPH,A
   \   00008C   8882         MOV     DPL,R0
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   E0           MOVX    A,@DPTR
   \   000098   F5..         MOV     ?V0 + 0,A
    298              pAddr2 = pCInfo->peerAddr;
   \   00009A   85..82       MOV     DPL,?XSP + 0
   \   00009D   85..83       MOV     DPH,?XSP + 1
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   2403         ADD     A,#0x3
   \   0000A3   F8           MOV     R0,A
   \   0000A4   A3           INC     DPTR
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   3400         ADDC    A,#0x0
   \   0000A8   F9           MOV     R1,A
   \   0000A9   7408         MOV     A,#0x8
   \   0000AB   8049         SJMP    ??nwk_QfindOldest_4
    299            }
    300            else if (RCV_NWK_PORT == rcv->type)
   \                     ??nwk_QfindOldest_1:
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   7006         JNZ     ??nwk_QfindOldest_5
    301            {
    302              port = rcv->t.port;
   \   0000B0   A3           INC     DPTR
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   F5..         MOV     ?V0 + 0,A
   \   0000B4   8048         SJMP    ??nwk_QfindOldest_6
    303            }
    304          #ifdef ACCESS_POINT
    305            else if (RCV_RAW_POLL_FRAME == rcv->type)
   \                     ??nwk_QfindOldest_5:
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   6402         XRL     A,#0x2
   \   0000B9   70BE         JNZ     ??nwk_QfindOldest_0
    306            {
    307              port   = *(MRFI_P_PAYLOAD(rcv->t.pkt)+F_APP_PAYLOAD_OS+M_POLL_PORT_OS);
   \   0000BB   A3           INC     DPTR
   \   0000BC   A882         MOV     R0,DPL
   \   0000BE   A983         MOV     R1,DPH
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   240E         ADD     A,#0xe
   \   0000C3   FA           MOV     R2,A
   \   0000C4   A3           INC     DPTR
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   3400         ADDC    A,#0x0
   \   0000C8   FB           MOV     R3,A
   \   0000C9   8A82         MOV     DPL,R2
   \   0000CB   8B83         MOV     DPH,R3
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   F5..         MOV     ?V0 + 0,A
    308              pAddr2 = MRFI_P_SRC_ADDR(rcv->t.pkt);
   \   0000D0   8882         MOV     DPL,R0
   \   0000D2   8983         MOV     DPH,R1
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   2405         ADD     A,#0x5
   \   0000D7   FA           MOV     R2,A
   \   0000D8   A3           INC     DPTR
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   3400         ADDC    A,#0x0
   \   0000DC   FB           MOV     R3,A
   \   0000DD   7408         MOV     A,#0x8
   \   0000DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E2   EA           MOV     A,R2
   \   0000E3   F0           MOVX    @DPTR,A
   \   0000E4   A3           INC     DPTR
   \   0000E5   EB           MOV     A,R3
   \   0000E6   F0           MOVX    @DPTR,A
    309              pAddr3 = MRFI_P_PAYLOAD(rcv->t.pkt)+F_APP_PAYLOAD_OS+M_POLL_ADDR_OS;
   \   0000E7   8882         MOV     DPL,R0
   \   0000E9   8983         MOV     DPH,R1
   \   0000EB   E0           MOVX    A,@DPTR
   \   0000EC   240F         ADD     A,#0xf
   \   0000EE   F8           MOV     R0,A
   \   0000EF   A3           INC     DPTR
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   3400         ADDC    A,#0x0
   \   0000F3   F9           MOV     R1,A
   \   0000F4   7402         MOV     A,#0x2
   \                     ??nwk_QfindOldest_4:
   \   0000F6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F9   E8           MOV     A,R0
   \   0000FA   F0           MOVX    @DPTR,A
   \   0000FB   A3           INC     DPTR
   \   0000FC   E9           MOV     A,R1
   \   0000FD   F0           MOVX    @DPTR,A
    310            }
    311          #endif
    312            else
    313            {
    314              return (frameInfo_t *)0;
    315            }
    316          
    317            uType = (USAGE_NORMAL == fi_usage) ? FI_INUSE_UNTIL_DEL : FI_INUSE_UNTIL_FWD;
   \                     ??nwk_QfindOldest_6:
   \   0000FE   740A         MOV     A,#0xa
   \   000100   12....       LCALL   ?XSTACK_DISP0_8
   \   000103   E0           MOVX    A,@DPTR
   \   000104   6401         XRL     A,#0x1
   \   000106   7005         JNZ     ??nwk_QfindOldest_7
   \   000108   75..01       MOV     ?V0 + 1,#0x1
   \   00010B   8003         SJMP    ??nwk_QfindOldest_8
   \                     ??nwk_QfindOldest_7:
   \   00010D   75..03       MOV     ?V0 + 1,#0x3
    318          
    319            for (i=0; i<num; ++i, ++wPtr)
   \                     ??nwk_QfindOldest_8:
   \   000110   75..00       MOV     ?V0 + 7,#0x0
   \   000113   800F         SJMP    ??nwk_QfindOldest_9
    320            {
    321          
    322              BSP_ENTER_CRITICAL_SECTION(intState);   /* protect the frame states */
    323          
    324              /* only check entries in use and waiting for this port */
    325              if (uType == wPtr->fi_usage)
    326              {
    327                wPtr->fi_usage = FI_INUSE_TRANSITION;
    328          
    329                BSP_EXIT_CRITICAL_SECTION(intState);  /* release hold */
    330                /* message sent to this device? */
    331                if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&wPtr->mrfiPkt), F_PORT_OS) == port)
    332                {
    333                  /* Port matches. If the port of interest is a NWK applicaiton we're a
    334                   * match...the NWK applications are not connection-based. If it is a
    335                   * NWK application we need to check the source address for disambiguation.
    336                   * Also need to check source address if it's a raw frame lookup (S&F frame)
    337                   */
    338                  if (RCV_APP_LID == rcv->type)
    339                  {
    340                    if (SMPL_PORT_USER_BCAST == port)
    341                    {
    342                      /* guarantee a match... */
    343                      pAddr1 = pCInfo->peerAddr;
    344                    }
    345                    else
    346                    {
    347                      pAddr1 = MRFI_P_SRC_ADDR(&wPtr->mrfiPkt);
    348                    }
    349                  }
    350          #ifdef ACCESS_POINT
    351                  else if (RCV_RAW_POLL_FRAME == rcv->type)
    352                  {
    353                    pAddr1 = MRFI_P_DST_ADDR(&wPtr->mrfiPkt);
    354                  }
    355          #endif
    356          
    357                  addr12Compare = memcmp(pAddr1, pAddr2, NET_ADDR_SIZE);
    358                  if (  (RCV_NWK_PORT == rcv->type) ||
    359                        (!pAddr3 && !addr12Compare) ||
    360                        (pAddr3 && !memcmp(pAddr3, MRFI_P_SRC_ADDR(&wPtr->mrfiPkt), NET_ADDR_SIZE))
    361                     )
    362                  {
    363                    if (wPtr->orderStamp < oldest)
    364                    {
    365                      if (fPtr)
    366                      {
    367                        /* restore previous oldest one */
    368                        fPtr->fi_usage = uType;
    369                      }
    370                      oldest = wPtr->orderStamp;
    371                      fPtr   = wPtr;
    372                      continue;
    373                    }
    374                    else
    375                    {
    376                      /* not oldest. restore state */
    377                      wPtr->fi_usage = uType;
    378                    }
    379                  }
    380                  else
    381                  {
    382                    /* not a match. restore state */
    383                    wPtr->fi_usage = uType;
    384                  }
    385                }
    386                else
    387                {
    388                  /* wrong port. restore state */
    389                  wPtr->fi_usage = uType;
    390                }
    391              }
    392              else
    393              {
    394                BSP_EXIT_CRITICAL_SECTION(intState);
   \                     ??nwk_QfindOldest_10:
   \   000115   E8           MOV     A,R0
   \   000116   A2E0         MOV     C,0xE0 /* A   */.0
   \   000118   92AF         MOV     0xa8.7,C
    395              }
   \                     ??nwk_QfindOldest_11:
   \   00011A   05..         INC     ?V0 + 7
   \   00011C   EE           MOV     A,R6
   \   00011D   2423         ADD     A,#0x23
   \   00011F   FE           MOV     R6,A
   \   000120   EF           MOV     A,R7
   \   000121   3400         ADDC    A,#0x0
   \   000123   FF           MOV     R7,A
   \                     ??nwk_QfindOldest_9:
   \   000124   E5..         MOV     A,?V0 + 7
   \   000126   C3           CLR     C
   \   000127   9406         SUBB    A,#0x6
   \   000129   4003         JC      $+5
   \   00012B   02....       LJMP    ??nwk_QfindOldest_12
   \   00012E   A2AF         MOV     C,0xa8.7
   \   000130   E4           CLR     A
   \   000131   33           RLC     A
   \   000132   F8           MOV     R0,A
   \   000133   C2AF         CLR     0xa8.7
   \   000135   8E82         MOV     DPL,R6
   \   000137   8F83         MOV     DPH,R7
   \   000139   E0           MOVX    A,@DPTR
   \   00013A   65..         XRL     A,?V0 + 1
   \   00013C   70D7         JNZ     ??nwk_QfindOldest_10
   \   00013E   7404         MOV     A,#0x4
   \   000140   F0           MOVX    @DPTR,A
   \   000141   E8           MOV     A,R0
   \   000142   A2E0         MOV     C,0xE0 /* A   */.0
   \   000144   92AF         MOV     0xa8.7,C
   \   000146   EE           MOV     A,R6
   \   000147   240B         ADD     A,#0xb
   \   000149   F582         MOV     DPL,A
   \   00014B   EF           MOV     A,R7
   \   00014C   3400         ADDC    A,#0x0
   \   00014E   F583         MOV     DPH,A
   \   000150   E0           MOVX    A,@DPTR
   \   000151   543F         ANL     A,#0x3f
   \   000153   65..         XRL     A,?V0 + 0
   \   000155   6003         JZ      $+5
   \   000157   02....       LJMP    ??nwk_QfindOldest_13
   \   00015A   85..82       MOV     DPL,?V0 + 2
   \   00015D   85..83       MOV     DPH,?V0 + 3
   \   000160   E0           MOVX    A,@DPTR
   \   000161   6401         XRL     A,#0x1
   \   000163   7019         JNZ     ??nwk_QfindOldest_14
   \   000165   743F         MOV     A,#0x3f
   \   000167   65..         XRL     A,?V0 + 0
   \   000169   700E         JNZ     ??nwk_QfindOldest_15
   \   00016B   85..82       MOV     DPL,?XSP + 0
   \   00016E   85..83       MOV     DPH,?XSP + 1
   \   000171   E0           MOVX    A,@DPTR
   \   000172   2403         ADD     A,#0x3
   \   000174   F8           MOV     R0,A
   \   000175   A3           INC     DPTR
   \   000176   E0           MOVX    A,@DPTR
   \   000177   800F         SJMP    ??nwk_QfindOldest_16
   \                     ??nwk_QfindOldest_15:
   \   000179   EE           MOV     A,R6
   \   00017A   2407         ADD     A,#0x7
   \   00017C   8008         SJMP    ??nwk_QfindOldest_17
   \                     ??nwk_QfindOldest_14:
   \   00017E   E0           MOVX    A,@DPTR
   \   00017F   6402         XRL     A,#0x2
   \   000181   7012         JNZ     ??nwk_QfindOldest_18
   \   000183   EE           MOV     A,R6
   \   000184   2403         ADD     A,#0x3
   \                     ??nwk_QfindOldest_17:
   \   000186   F8           MOV     R0,A
   \   000187   EF           MOV     A,R7
   \                     ??nwk_QfindOldest_16:
   \   000188   3400         ADDC    A,#0x0
   \   00018A   F9           MOV     R1,A
   \   00018B   7404         MOV     A,#0x4
   \   00018D   12....       LCALL   ?XSTACK_DISP0_8
   \   000190   E8           MOV     A,R0
   \   000191   F0           MOVX    @DPTR,A
   \   000192   A3           INC     DPTR
   \   000193   E9           MOV     A,R1
   \   000194   F0           MOVX    @DPTR,A
   \                     ??nwk_QfindOldest_18:
   \   000195                ; Setup parameters for call to function memcmp
   \   000195   75..04       MOV     ?V0 + 4,#0x4
   \   000198   75..00       MOV     ?V0 + 5,#0x0
   \   00019B   78..         MOV     R0,#?V0 + 4
   \   00019D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001A0   740A         MOV     A,#0xa
   \   0001A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A5   E0           MOVX    A,@DPTR
   \   0001A6   FC           MOV     R4,A
   \   0001A7   A3           INC     DPTR
   \   0001A8   E0           MOVX    A,@DPTR
   \   0001A9   FD           MOV     R5,A
   \   0001AA   7406         MOV     A,#0x6
   \   0001AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AF   E0           MOVX    A,@DPTR
   \   0001B0   FA           MOV     R2,A
   \   0001B1   A3           INC     DPTR
   \   0001B2   E0           MOVX    A,@DPTR
   \   0001B3   FB           MOV     R3,A
   \   0001B4   12....       LCALL   memcmp
   \   0001B7   7402         MOV     A,#0x2
   \   0001B9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001BC   85..82       MOV     DPL,?V0 + 2
   \   0001BF   85..83       MOV     DPH,?V0 + 3
   \   0001C2   E0           MOVX    A,@DPTR
   \   0001C3   6045         JZ      ??nwk_QfindOldest_19
   \   0001C5   7402         MOV     A,#0x2
   \   0001C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CA   E0           MOVX    A,@DPTR
   \   0001CB   F8           MOV     R0,A
   \   0001CC   A3           INC     DPTR
   \   0001CD   E0           MOVX    A,@DPTR
   \   0001CE   F9           MOV     R1,A
   \   0001CF   E8           MOV     A,R0
   \   0001D0   49           ORL     A,R1
   \   0001D1   7003         JNZ     ??nwk_QfindOldest_20
   \   0001D3   EA           MOV     A,R2
   \   0001D4   6034         JZ      ??nwk_QfindOldest_19
   \                     ??nwk_QfindOldest_20:
   \   0001D6   7402         MOV     A,#0x2
   \   0001D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DB   E0           MOVX    A,@DPTR
   \   0001DC   F8           MOV     R0,A
   \   0001DD   A3           INC     DPTR
   \   0001DE   E0           MOVX    A,@DPTR
   \   0001DF   F9           MOV     R1,A
   \   0001E0   E8           MOV     A,R0
   \   0001E1   49           ORL     A,R1
   \   0001E2   6067         JZ      ??nwk_QfindOldest_13
   \   0001E4                ; Setup parameters for call to function memcmp
   \   0001E4   78..         MOV     R0,#?V0 + 4
   \   0001E6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001E9   EE           MOV     A,R6
   \   0001EA   2407         ADD     A,#0x7
   \   0001EC   FC           MOV     R4,A
   \   0001ED   EF           MOV     A,R7
   \   0001EE   3400         ADDC    A,#0x0
   \   0001F0   FD           MOV     R5,A
   \   0001F1   7404         MOV     A,#0x4
   \   0001F3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F6   E0           MOVX    A,@DPTR
   \   0001F7   FA           MOV     R2,A
   \   0001F8   A3           INC     DPTR
   \   0001F9   E0           MOVX    A,@DPTR
   \   0001FA   FB           MOV     R3,A
   \   0001FB   12....       LCALL   memcmp
   \   0001FE   7402         MOV     A,#0x2
   \   000200   12....       LCALL   ?DEALLOC_XSTACK8
   \   000203   8B..         MOV     ?V0 + 5,R3
   \   000205   EA           MOV     A,R2
   \   000206   45..         ORL     A,?V0 + 5
   \   000208   7041         JNZ     ??nwk_QfindOldest_13
   \                     ??nwk_QfindOldest_19:
   \   00020A   8E82         MOV     DPL,R6
   \   00020C   8F83         MOV     DPH,R7
   \   00020E   A3           INC     DPTR
   \   00020F   AA82         MOV     R2,DPL
   \   000211   AB83         MOV     R3,DPH
   \   000213   E0           MOVX    A,@DPTR
   \   000214   C3           CLR     C
   \   000215   95..         SUBB    A,?V0 + 6
   \   000217   5032         JNC     ??nwk_QfindOldest_13
   \   000219   7406         MOV     A,#0x6
   \   00021B   12....       LCALL   ?XSTACK_DISP0_8
   \   00021E   E0           MOVX    A,@DPTR
   \   00021F   F8           MOV     R0,A
   \   000220   A3           INC     DPTR
   \   000221   E0           MOVX    A,@DPTR
   \   000222   F9           MOV     R1,A
   \   000223   E8           MOV     A,R0
   \   000224   49           ORL     A,R1
   \   000225   6010         JZ      ??nwk_QfindOldest_21
   \   000227   7406         MOV     A,#0x6
   \   000229   12....       LCALL   ?XSTACK_DISP0_8
   \   00022C   E0           MOVX    A,@DPTR
   \   00022D   F8           MOV     R0,A
   \   00022E   A3           INC     DPTR
   \   00022F   E0           MOVX    A,@DPTR
   \   000230   F583         MOV     DPH,A
   \   000232   8882         MOV     DPL,R0
   \   000234   E5..         MOV     A,?V0 + 1
   \   000236   F0           MOVX    @DPTR,A
   \                     ??nwk_QfindOldest_21:
   \   000237   8A82         MOV     DPL,R2
   \   000239   8B83         MOV     DPH,R3
   \   00023B   E0           MOVX    A,@DPTR
   \   00023C   F5..         MOV     ?V0 + 6,A
   \   00023E   7406         MOV     A,#0x6
   \   000240   12....       LCALL   ?XSTACK_DISP0_8
   \   000243   EE           MOV     A,R6
   \   000244   F0           MOVX    @DPTR,A
   \   000245   A3           INC     DPTR
   \   000246   EF           MOV     A,R7
   \                     ??nwk_QfindOldest_22:
   \   000247   F0           MOVX    @DPTR,A
   \   000248   02....       LJMP    ??nwk_QfindOldest_11
   \                     ??nwk_QfindOldest_13:
   \   00024B   8E82         MOV     DPL,R6
   \   00024D   8F83         MOV     DPH,R7
   \   00024F   E5..         MOV     A,?V0 + 1
   \   000251   80F4         SJMP    ??nwk_QfindOldest_22
    396            }
    397          
    398            return fPtr;
   \                     ??nwk_QfindOldest_12:
   \   000253   7406         MOV     A,#0x6
   \   000255   12....       LCALL   ?XSTACK_DISP0_8
   \   000258   E0           MOVX    A,@DPTR
   \   000259   FA           MOV     R2,A
   \   00025A   A3           INC     DPTR
   \   00025B   E0           MOVX    A,@DPTR
   \   00025C   FB           MOV     R3,A
   \                     ??nwk_QfindOldest_3:
   \   00025D   740C         MOV     A,#0xc
   \   00025F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000262   7F08         MOV     R7,#0x8
   \   000264   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   000267                REQUIRE _A_IEN0
    399          }
    400          
    401          /******************************************************************************
    402           * @fn          nwk_getQ
    403           *
    404           * @brief       Get location of teh specified frame queue.
    405           *
    406           * input parameters
    407           * @param   which   - INQ or OUTQ to get
    408           *
    409           * output parameters
    410           *
    411           * @return      Pointer to frame queue
    412           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    413          frameInfo_t *nwk_getQ(uint8_t which)
   \                     nwk_getQ:
    414          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    415            return (INQ == which) ? sInFrameQ : sOutFrameQ;
   \   000000   7401         MOV     A,#0x1
   \   000002   69           XRL     A,R1
   \   000003   7005         JNZ     ??nwk_getQ_0
   \   000005   7A..         MOV     R2,#sInFrameQ & 0xff
   \   000007   7B..         MOV     R3,#(sInFrameQ >> 8) & 0xff
   \   000009   22           RET
   \                     ??nwk_getQ_0:
   \   00000A   7A..         MOV     R2,#sOutFrameQ & 0xff
   \   00000C   7B..         MOV     R3,#(sOutFrameQ >> 8) & 0xff
   \   00000E   22           RET
    416          }
    417          

   Maximum stack usage in bytes:

     Function              ISTACK PSTACK XSTACK
     --------              ------ ------ ------
     nwk_QInit                 0      0     11
       -> memset               0      0     22
       -> memset               0      0     22
     nwk_QadjustOrder          0      0     19
     nwk_QfindOldest           1      0     29
       -> nwk_getConnInfo      0      0     54
       -> memcmp               0      0     58
       -> memcmp               0      0     58
     nwk_QfindSlot             1      0     11
       -> nwk_QadjustOrder     0      0     22
     nwk_getQ                  0      0      0


   Segment part sizes:

     Function/Label   Bytes
     --------------   -----
     _A_IEN0             1
     sInFrameQ         210
     sOutFrameQ         70
     nwk_QInit          61
     nwk_QfindSlot     161
     nwk_QadjustOrder   70
     nwk_QfindOldest   615
     nwk_getQ           15

 
 922 bytes in segment NEAR_CODE
   1 byte  in segment SFR_AN
 280 bytes in segment XDATA_Z
 
 922 bytes of CODE  memory
   0 bytes of DATA  memory (+ 1 byte shared)
 280 bytes of XDATA memory

Errors: none
Warnings: none
